{
  "name": "Compta Balance",
  "nodes": [
    {
      "parameters": {
        "path": "compta-balance",
        "responseMode": "responseNode",
        "method": "POST",
        "httpMethod": "POST"
      },
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        250,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "var body = $input.first().json;\nvar tenantId = body.tenantId;\nvar dateFrom = body.dateFrom;\nvar dateTo = body.dateTo;\n\nreturn {\n  tenantId,\n  dateFrom,\n  dateTo\n};"
      },
      "id": "parser",
      "name": "Parser",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        450,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "{{ $node.parser.json.tenantId }}",
              "operation": "notEmpty"
            }
          ]
        }
      },
      "id": "if_valide",
      "name": "IF Valide",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        650,
        300
      ]
    },
    {
      "parameters": {
        "respondWithOptions": {
          "responseType": "json"
        },
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"tenantId is required\"\n}"
      },
      "id": "respond_error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        850,
        150
      ]
    },
    {
      "parameters": {
        "jsCode": "function esc(str) {\n  if (str === null || str === undefined) return 'NULL';\n  if (typeof str === 'number') return str.toString();\n  var escaped = str.toString().replace(/'/g, \"''\");\n  return `'${escaped}'`;\n}\n\nvar tenantId = $node.parser.json.tenantId;\nvar dateFrom = $node.parser.json.dateFrom;\nvar dateTo = $node.parser.json.dateTo;\n\nvar dateFilter = '';\nif (dateFrom && dateTo) {\n  dateFilter = `AND e.date_ecriture >= ${esc(dateFrom)} AND e.date_ecriture <= ${esc(dateTo)}`;\n} else if (dateFrom) {\n  dateFilter = `AND e.date_ecriture >= ${esc(dateFrom)}`;\n} else if (dateTo) {\n  dateFilter = `AND e.date_ecriture <= ${esc(dateTo)}`;\n}\n\nvar query = `SELECT le.numero_compte, pc.libelle as compte_libelle, pc.classe,\n  COALESCE(SUM(le.debit), 0) as total_debit,\n  COALESCE(SUM(le.credit), 0) as total_credit\nFROM lignes_ecritures le\nJOIN ecritures_comptables e ON le.ecriture_id = e.id\nLEFT JOIN plan_comptable pc ON le.numero_compte = pc.numero_compte AND pc.tenant_id = e.tenant_id\nWHERE e.tenant_id = ${esc(tenantId)}::uuid AND e.statut = 'validee'\n  ${dateFilter}\nGROUP BY le.numero_compte, pc.libelle, pc.classe\nHAVING COALESCE(SUM(le.debit), 0) != 0 OR COALESCE(SUM(le.credit), 0) != 0\nORDER BY le.numero_compte ASC`;\n\nreturn {\n  query\n};"
      },
      "id": "build_queries",
      "name": "Build Queries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        850,
        300
      ]
    },
    {
      "parameters": {
        "nodeCredentialType": "postgres",
        "nodeCredentials": {
          "postgres": "OGqj65ZoFRileCck"
        },
        "query": "{{ $node.build_queries.json.query }}",
        "alwaysOutputData": true
      },
      "id": "query_balance",
      "name": "Query Balance",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1050,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "var classLabels = {\n  1: 'Comptes de capitaux',\n  2: \"Comptes d'immobilisations\",\n  3: 'Comptes de stocks',\n  4: 'Comptes de tiers',\n  5: 'Comptes financiers',\n  6: 'Comptes de charges',\n  7: 'Comptes de produits'\n};\n\nvar data = $input.first().json;\nvar rows = Array.isArray(data) ? data : (data.rows || []);\n\nvar grouped = {};\nrows.forEach(row => {\n  var classe = row.classe || 0;\n  if (!grouped[classe]) {\n    grouped[classe] = [];\n  }\n  grouped[classe].push(row);\n});\n\nvar classes = Object.keys(grouped)\n  .sort((a, b) => parseInt(a) - parseInt(b))\n  .map(classKey => {\n    var classe = parseInt(classKey);\n    var comptes = grouped[classe].map(row => {\n      var debit = parseFloat(row.total_debit) || 0;\n      var credit = parseFloat(row.total_credit) || 0;\n      var solde = debit - credit;\n      return {\n        numeroCompte: row.numero_compte,\n        libelleCompte: row.compte_libelle || '',\n        totalDebit: debit,\n        totalCredit: credit,\n        soldeDebiteur: solde > 0 ? solde : 0,\n        soldeCrediteur: solde < 0 ? Math.abs(solde) : 0\n      };\n    });\n\n    var classeTotals = comptes.reduce((acc, compte) => ({\n      totalDebit: acc.totalDebit + compte.totalDebit,\n      totalCredit: acc.totalCredit + compte.totalCredit,\n      totalSoldeDebiteur: acc.totalSoldeDebiteur + compte.soldeDebiteur,\n      totalSoldeCrediteur: acc.totalSoldeCrediteur + compte.soldeCrediteur\n    }), {\n      totalDebit: 0,\n      totalCredit: 0,\n      totalSoldeDebiteur: 0,\n      totalSoldeCrediteur: 0\n    });\n\n    return {\n      classe,\n      libelleClasse: classLabels[classe] || '',\n      comptes,\n      ...classeTotals\n    };\n  });\n\nvar totauxGeneraux = classes.reduce((acc, classeData) => ({\n  totalDebit: acc.totalDebit + classeData.totalDebit,\n  totalCredit: acc.totalCredit + classeData.totalCredit,\n  totalSoldeDebiteur: acc.totalSoldeDebiteur + classeData.totalSoldeDebiteur,\n  totalSoldeCrediteur: acc.totalSoldeCrediteur + classeData.totalSoldeCrediteur\n}), {\n  totalDebit: 0,\n  totalCredit: 0,\n  totalSoldeDebiteur: 0,\n  totalSoldeCrediteur: 0\n});\n\nreturn {\n  success: true,\n  classes,\n  totauxGeneraux\n};"
      },
      "id": "format_response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1250,
        300
      ]
    },
    {
      "parameters": {
        "respondWithOptions": {
          "responseType": "json"
        },
        "responseBody": "{{ $node.format_response.json }}"
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1450,
        300
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parser": {
      "main": [
        [
          {
            "node": "IF Valide",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Valide": {
      "main": [
        [
          {
            "node": "Build Queries",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Queries": {
      "main": [
        [
          {
            "node": "Query Balance",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Balance": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1"
}