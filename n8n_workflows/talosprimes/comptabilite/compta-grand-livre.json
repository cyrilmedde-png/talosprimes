{
  "name": "Comptabilité - Grand Livre",
  "nodes": [
    {
      "parameters": {
        "path": "compta-grand-livre",
        "responseMode": "responseNode",
        "method": "POST"
      },
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        0,
        200
      ],
      "webhookId": "uuid-will-be-generated",
      "disabled": false
    },
    {
      "parameters": {
        "jsCode": "var body = $input.first().json;\n\n// Extract and validate UUID format\nvar uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\nvar tenantId = body.tenantId || body.tenant_id;\nvar dateFrom = body.dateFrom || body.date_from || body.period?.dateFrom;\nvar dateTo = body.dateTo || body.date_to || body.period?.dateTo;\nvar compteFrom = body.compteFrom || body.compte_from || null;\nvar compteTo = body.compteTo || body.compte_to || null;\n\nvar isValidUUID = (id) => {\n  if (!id || typeof id !== 'string') return false;\n  return uuidRegex.test(id);\n};\n\nvar isValidDate = (date) => {\n  if (!date || typeof date !== 'string') return false;\n  return !isNaN(new Date(date).getTime());\n};\n\nreturn {\n  tenantId,\n  dateFrom,\n  dateTo,\n  compteFrom,\n  compteTo,\n  validations: {\n    tenantIdValid: isValidUUID(tenantId),\n    dateFromValid: isValidDate(dateFrom),\n    dateToValid: isValidDate(dateTo),\n    comptesValid: !compteFrom || !compteTo || (typeof compteFrom === 'string' && typeof compteTo === 'string')\n  }\n};"
      },
      "id": "parser",
      "name": "Parser",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        200
      ],
      "disabled": false
    },
    {
      "parameters": {
        "conditions": {
          "nodeOutputs": [
            {
              "conditions": [
                {
                  "key": "validations.tenantIdValid",
                  "condition": "notEmpty"
                },
                {
                  "key": "validations.dateFromValid",
                  "condition": "notEmpty"
                },
                {
                  "key": "validations.dateToValid",
                  "condition": "notEmpty"
                }
              ],
              "combinator": "and",
              "type": "object"
            }
          ]
        }
      },
      "id": "if_valide",
      "name": "IF Valide",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        400,
        200
      ],
      "disabled": false
    },
    {
      "parameters": {
        "respondWithData": "{{ {error: 'Invalid request parameters', details: $json.validations} }}"
      },
      "id": "respond_error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        600,
        400
      ],
      "disabled": false
    },
    {
      "parameters": {
        "jsCode": "var { tenantId, dateFrom, dateTo, compteFrom, compteTo } = $input.first().json;\n\n// Helper function to safely escape SQL strings\nvar esc = (value) => {\n  if (value === null || value === undefined) return 'NULL';\n  if (typeof value === 'boolean') return value ? 'true' : 'false';\n  if (typeof value === 'number') return value.toString();\n  \n  // For UUIDs and dates, use parameterized query style\n  if (typeof value === 'string') {\n    // Return the string as-is for parameterized placeholders\n    return value.replace(/'/g, \"''\");\n  }\n  return value.toString().replace(/'/g, \"''\");\n};\n\n// Build the base query\nvar query = `\nSELECT \n  le.numero_compte, \n  pc.libelle as compte_libelle, \n  e.date_ecriture, \n  e.numero_piece, \n  e.journal_code, \n  le.libelle_ligne, \n  le.debit, \n  le.credit\nFROM lignes_ecritures le\nJOIN ecritures_comptables e ON le.ecriture_id = e.id\nLEFT JOIN plan_comptable pc ON le.numero_compte = pc.numero_compte AND pc.tenant_id = e.tenant_id\nWHERE e.tenant_id = '${esc(tenantId)}'::uuid \n  AND e.statut = 'validee'\n`;\n\n// Add date filters\nif (dateFrom) {\n  query += ` AND e.date_ecriture >= '${esc(dateFrom)}'`;\n}\nif (dateTo) {\n  query += ` AND e.date_ecriture <= '${esc(dateTo)}'`;\n}\n\n// Add account range filters\nif (compteFrom) {\n  query += ` AND le.numero_compte >= '${esc(compteFrom)}'`;\n}\nif (compteTo) {\n  query += ` AND le.numero_compte <= '${esc(compteTo)}'`;\n}\n\nquery += `\nORDER BY le.numero_compte ASC, e.date_ecriture ASC, le.ordre ASC\n`;\n\nreturn {\n  query,\n  tenantId,\n  dateFrom,\n  dateTo,\n  compteFrom,\n  compteTo\n};"
      },
      "id": "build_queries",
      "name": "Build Queries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        200
      ],
      "disabled": false
    },
    {
      "parameters": {
        "credentialsToUse": {
          "credentialType": "postgres",
          "credentialId": "OGqj65ZoFRileCck"
        },
        "queryType": "native",
        "nativeQuery": "{{ $json.query }}",
        "alwaysOutputData": true
      },
      "id": "query_grand_livre",
      "name": "Query Grand Livre",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        800,
        200
      ],
      "disabled": false
    },
    {
      "parameters": {
        "jsCode": "var rows = $input.first().json.data || [];\nvar { dateFrom, dateTo, tenantId } = $input.first().json;\n\n// Group by numero_compte\nvar compteMap = {};\n\nvar totalDebit = 0;\nvar totalCredit = 0;\n\nrows.forEach((row) => {\n  var numeroCompte = row.numero_compte || '';\n  var libelleCompte = row.compte_libelle || 'Sans libellé';\n  var debit = parseFloat(row.debit) || 0;\n  var credit = parseFloat(row.credit) || 0;\n\n  totalDebit += debit;\n  totalCredit += credit;\n\n  if (!compteMap[numeroCompte]) {\n    compteMap[numeroCompte] = {\n      numeroCompte,\n      libelleCompte,\n      totalDebit: 0,\n      totalCredit: 0,\n      solde: 0,\n      lignes: []\n    };\n  }\n\n  compteMap[numeroCompte].totalDebit += debit;\n  compteMap[numeroCompte].totalCredit += credit;\n\n  // Add line to compte\n  compteMap[numeroCompte].lignes.push({\n    date: row.date_ecriture,\n    journalCode: row.journal_code,\n    numeroEcriture: row.numero_piece || null,\n    libelle: row.libelle_ligne,\n    debit,\n    credit\n  });\n});\n\n// Calculate solde and running balance (soldeCumule) for each compte\nvar comptes = Object.values(compteMap).map((compte) => {\n  compte.solde = compte.totalDebit - compte.totalCredit;\n  \n  // Calculate running balance (soldeCumule) for each line\n  var runningBalance = 0;\n  compte.lignes.forEach((ligne) => {\n    runningBalance += (ligne.debit - ligne.credit);\n    ligne.soldeCumule = runningBalance;\n  });\n\n  return compte;\n});\n\nvar response = {\n  success: true,\n  comptes,\n  totaux: {\n    totalDebit,\n    totalCrebit\n  },\n  periode: {\n    dateFrom: dateFrom || null,\n    dateTo: dateTo || null\n  }\n};\n\nreturn response;"
      },
      "id": "format_response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        200
      ],
      "disabled": false
    },
    {
      "parameters": {
        "respondWithData": "{{ $json }}"
      },
      "id": "respond_success",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1200,
        200
      ],
      "disabled": false
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parser": {
      "main": [
        [
          {
            "node": "IF Valide",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Valide": {
      "main": [
        [
          {
            "node": "Build Queries",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Queries": {
      "main": [
        [
          {
            "node": "Query Grand Livre",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Grand Livre": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "errorHandler": "continueErrorHandler",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },
  "staticData": null,
  "hash": "",
  "id": ""
}