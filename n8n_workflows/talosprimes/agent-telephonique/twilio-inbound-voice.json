{
  "name": "twilio-inbound-voice",
  "nodes": [
    {
      "parameters": {
        "path": "twilio-inbound-voice",
        "responseMode": "responseNode",
        "httpMethod": "POST",
        "options": {
          "rawBody": true
        }
      },
      "id": "01. Webhook Twilio",
      "name": "01. Webhook Twilio",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        100,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse Twilio webhook payload (form-urlencoded) avec validation anti-injection\nconst data = $input.first().json;\nconst body = data.body || data;\n\n// Regex de validation pour les champs Twilio\nconst CALLSID_RE = /^CA[0-9a-f]{32}$/i;\nconst PHONE_RE = /^\\+?[0-9]{6,15}$/;\n\n// Nettoyer : ne garder que les caractères attendus\nfunction sanitizePhone(p) { return String(p || '').replace(/[^+0-9]/g, '').substring(0, 16); }\nfunction sanitizeCallSid(s) { return String(s || '').replace(/[^a-zA-Z0-9]/g, '').substring(0, 34); }\nfunction sanitizeText(t) { return String(t || '').replace(/'/g, \"''\").substring(0, 2000); }\n\nconst callSid = sanitizeCallSid(body.CallSid);\nconst from = sanitizePhone(body.From);\nconst to = sanitizePhone(body.To);\nconst callStatus = String(body.CallStatus || '').replace(/[^a-z-]/gi, '').substring(0, 30);\nconst speechResult = sanitizeText(body.SpeechResult);\nconst digits = String(body.Digits || '').replace(/[^0-9*#]/g, '').substring(0, 20);\nconst isCallback = !!speechResult || !!digits;\n\nreturn [{json: {\n  callSid,\n  from,\n  to,\n  callStatus,\n  speechResult,\n  digits,\n  isCallback\n}}];"
      },
      "id": "02. Parser Twilio",
      "name": "02. Parser Twilio",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        300,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isCallback }}",
              "value2": true
            }
          ]
        }
      },
      "id": "03. Is Callback?",
      "name": "03. Is Callback?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        500,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Premier appel : message d'accueil + Gather\nconst callSid = $('02. Parser Twilio').first().json.callSid;\nconst from = $('02. Parser Twilio').first().json.from;\n\nconst twiml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n  <Say voice=\"Polly.Lea-Neural\" language=\"fr-FR\">TalosPrimes, bonjour ! Comment puis-je vous aider ?</Say>\n  <Gather input=\"speech\" language=\"fr-FR\" speechTimeout=\"3\" timeout=\"15\" action=\"https://n8n.talosprimes.com/webhook/twilio-inbound-voice\" method=\"POST\"/>\n  <Say voice=\"Polly.Lea-Neural\" language=\"fr-FR\">Je n'ai pas entendu de réponse. Au revoir !</Say>\n</Response>`;\n\nreturn { twiml, callSid, from };"
      },
      "id": "04. Welcome TwiML",
      "name": "04. Welcome TwiML",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        450
      ]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $json.twiml }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "text/xml; charset=utf-8"
              }
            ]
          }
        }
      },
      "id": "05. Respond Welcome",
      "name": "05. Respond Welcome",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        900,
        450
      ]
    },
    {
      "parameters": {
        "jsCode": "// Callback avec SpeechResult\nconst prev = $('02. Parser Twilio').first().json;\nconst speechResult = prev.speechResult;\nconst callSid = prev.callSid;\nconst from = prev.from;\n\nif (!speechResult || speechResult.trim() === '') {\n  return [{json: { callSid, from, speechResult: '', hasText: false }}];\n}\n\nreturn [{json: { callSid, from, speechResult: speechResult.trim(), hasText: true }}];"
      },
      "id": "06. Extract Speech",
      "name": "06. Extract Speech",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.hasText }}",
              "value2": true
            }
          ]
        }
      },
      "id": "07. Has Text?",
      "name": "07. Has Text?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        900,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Pas de texte détecté, on relance l'écoute\nconst twiml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n  <Say voice=\"Polly.Lea-Neural\" language=\"fr-FR\">Excusez-moi, je n'ai pas compris. Pouvez-vous répéter ?</Say>\n  <Gather input=\"speech\" language=\"fr-FR\" speechTimeout=\"3\" timeout=\"15\" action=\"https://n8n.talosprimes.com/webhook/twilio-inbound-voice\" method=\"POST\"/>\n  <Say voice=\"Polly.Lea-Neural\" language=\"fr-FR\">Au revoir.</Say>\n</Response>`;\n\nreturn { twiml };"
      },
      "id": "08. No Text TwiML",
      "name": "08. No Text TwiML",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        100
      ]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $json.twiml }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "text/xml; charset=utf-8"
              }
            ]
          }
        }
      },
      "id": "09. Respond No Text",
      "name": "09. Respond No Text",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1300,
        100
      ]
    },
    {
      "parameters": {
        "jsCode": "// Détecter l'admin avec la phrase secrète\nconst speechResult = $('06. Extract Speech').first().json.speechResult;\nconst callSid = $('06. Extract Speech').first().json.callSid;\nconst from = $('06. Extract Speech').first().json.from;\n\n// Normaliser : minuscule, sans accents, sans ponctuation\nconst normalized = speechResult.toLowerCase()\n  .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n  .replace(/[^a-z0-9\\s]/g, '')\n  .replace(/\\s+/g, ' ').trim();\n\n// Variantes phonétiques que Twilio STT peut produire pour \"c'est giizmo\"\nconst adminPatterns = [\n  'giizmo', 'gizmo', 'gismo', 'guismo', 'guizmo', 'gisemo',\n  'giz mo', 'gis mo', 'guiz mo', 'geez mo', 'geezmo',\n  'cest giizmo', 'cest gizmo', 'cest gismo', 'cest guismo',\n  'ses gizmo', 'ses giizmo', 'say gizmo', 'sai gizmo',\n  'ces gizmo', 'ces giizmo', 'se gizmo', 'se giizmo'\n];\n\nconst isAdminPhrase = adminPatterns.some(p => normalized.includes(p));\n\nreturn {\n  callSid,\n  from,\n  speechResult,\n  isAdminPhrase,\n  mode: isAdminPhrase ? 'admin' : 'standard'\n};"
      },
      "id": "10. Detect Admin",
      "name": "10. Detect Admin",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        250
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT cf.id, cf.nom, cf.prenom, cf.email, cf.telephone, cf.raison_sociale, cf.tenant_id FROM client_finals cf WHERE cf.telephone LIKE '%' || RIGHT($1, 9) || '%' LIMIT 1",
        "options": {
          "alwaysOutputData": true
        },
        "queryParameters": "={{ [$json.from] }}"
      },
      "id": "11. Get Session",
      "name": "11. Get Session",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "credentials": {
        "postgres": {
          "name": "Supabase Postgres",
          "id": "OGqj65ZoFRileCck"
        }
      },
      "position": [
        1300,
        250
      ]
    },
    {
      "parameters": {
        "jsCode": "// Construire le prompt avec FAQ + historique + tools (function calling)\nconst prev = $('10. Detect Admin').first().json;\nconst session = $('11. Get Session').first().json;\nconst historyRows = $('20. Load History').all();\nconst isAdmin = prev.isAdminPhrase;\nconst speechResult = prev.speechResult;\nconst callSid = prev.callSid;\nconst from = prev.from;\nconst clientName = session.nom || '';\nconst clientPrenom = session.prenom || '';\nconst clientEmail = session.email || '';\nconst clientId = session.id || '';\nconst tenantId = session.tenant_id || '';\nconst clientInfo = clientName ? `Client identifié: ${clientPrenom} ${clientName}${clientEmail ? ' (' + clientEmail + ')' : ''}. ID: ${clientId}` : 'Appelant non identifié dans notre base.';\n\n// Reconstruire l'historique de conversation\nlet conversationHistory = '';\nif (historyRows && historyRows.length > 0) {\n  const exchanges = [];\n  for (const row of historyRows) {\n    const notes = row.json.notes || '';\n    const qMatch = notes.match(/Q: (.+?) - R: /);\n    const rMatch = notes.match(/R: (.+)$/);\n    if (qMatch && rMatch) {\n      exchanges.push(`Appelant: ${qMatch[1]}\\nLéa: ${rMatch[1]}`);\n    }\n  }\n  if (exchanges.length > 0) {\n    conversationHistory = '\\nHISTORIQUE DE LA CONVERSATION:\\n' + exchanges.join('\\n') + '\\n';\n  }\n}\n\nconst faqContext = `PLATEFORME TALOSPRIMES - RÉSUMÉ:\nTalosPrimes est un LOGICIEL SaaS (Software as a Service) de gestion tout-en-un destiné aux professionnels de l'immobilier. TalosPrimes N'EST PAS une agence immobilière. C'est un éditeur de logiciel qui fournit des outils numériques aux agences, syndics, administrateurs de biens et promoteurs.\n\nMODULES: CRM/Leads, Gestion Clients B2B/B2C, Facturation (PDF auto, relances, Stripe), Devis, Bons de Commande, Avoirs, Comptabilité (PCG, journaux, TVA, bilan), Catalogue Articles, Téléphonie IA, SMS, Email IA, Agenda, Agent IA (17 outils), Espace Client, Qonto, 100+ workflows automatisés.\nTARIFS: sur devis. INSCRIPTION: app.talosprimes.com/inscription`;\n\nconst standardPrompt = `Tu es Léa, l'assistante vocale de TalosPrimes.\n${clientInfo}\n${conversationHistory}\n${faqContext}\n\nTU DISPOSES D'OUTILS pour créer des leads et rechercher des clients. Utilise-les quand c'est pertinent.\n\nCOMPORTEMENT:\n1. RÉPONDS aux questions sur la plateforme avec des infos PRÉCISES\n2. Si prospect intéressé: utilise l'outil create_lead pour enregistrer ses coordonnées\n3. Si problème TECHNIQUE COMPLEXE: dis que le service technique le recontactera sous 24h\n4. Si CLIENT avec souci simple: GUIDE-LE étape par étape\n5. JAMAIS dire \"contactez un administrateur via l'application\" - TU ES le point de contact\n6. Utilise l'HISTORIQUE pour ne pas répéter\n7. NE RÉPÈTE JAMAIS la même question. Ne redemande JAMAIS les coordonnées si déjà fait.\n\nRÈGLES VOCALES:\n- Maximum 3 phrases courtes et naturelles\n- Parle comme une vraie personne, chaleureuse et pro\n- Vouvoie toujours\n- Pas de listes, pas de formatage`;\n\nconst adminPrompt = `Tu es l'assistante IA de Giizmo, administrateur de TalosPrimes. Accès complet.\n${clientInfo}\n${conversationHistory}\n\nTU DISPOSES D'OUTILS pour créer et consulter leads, clients, factures, bons de commande. Utilise-les quand Giizmo te le demande.\n\nARCHITECTURE: Fastify+Prisma+PostgreSQL, Next.js, n8n, Twilio, Stripe, Qonto, OpenAI\n\nRÈGLES:\n- Maximum 3 phrases, direct et efficace\n- Confirme avant de créer quoi que ce soit\n- Infos techniques précises`;\n\n// Définir les tools disponibles\nconst standardTools = [\n  {\n    type: \"function\",\n    function: {\n      name: \"create_lead\",\n      description: \"Créer un nouveau prospect/lead dans le CRM. Utiliser quand un appelant donne ses coordonnées ou est intéressé par la plateforme.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          nom: { type: \"string\", description: \"Nom de famille du prospect\" },\n          prenom: { type: \"string\", description: \"Prénom du prospect\" },\n          email: { type: \"string\", description: \"Adresse email\" },\n          telephone: { type: \"string\", description: \"Numéro de téléphone\" },\n          notes: { type: \"string\", description: \"Notes sur la demande du prospect\" }\n        },\n        required: [\"nom\", \"telephone\"]\n      }\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"search_client\",\n      description: \"Rechercher un client par nom ou téléphone dans la base de données.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          query: { type: \"string\", description: \"Nom, prénom ou numéro de téléphone à rechercher\" }\n        },\n        required: [\"query\"]\n      }\n    }\n  }\n];\n\nconst adminTools = [\n  ...standardTools,\n  {\n    type: \"function\",\n    function: {\n      name: \"create_client\",\n      description: \"Créer un nouveau client dans le système.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          nom: { type: \"string\", description: \"Nom de famille\" },\n          prenom: { type: \"string\", description: \"Prénom\" },\n          email: { type: \"string\", description: \"Email (obligatoire)\" },\n          telephone: { type: \"string\", description: \"Téléphone\" },\n          type: { type: \"string\", enum: [\"b2b\", \"b2c\"], description: \"Type: b2b ou b2c\" },\n          raison_sociale: { type: \"string\", description: \"Raison sociale (si B2B)\" }\n        },\n        required: [\"email\", \"type\"]\n      }\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"create_invoice\",\n      description: \"Créer une facture brouillon pour un client.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          client_name_or_phone: { type: \"string\", description: \"Nom ou téléphone du client\" },\n          description: { type: \"string\", description: \"Description de la facture\" },\n          montant_ht: { type: \"number\", description: \"Montant HT en euros\" },\n          tva_taux: { type: \"number\", description: \"Taux de TVA (ex: 20 pour 20%)\", default: 20 }\n        },\n        required: [\"client_name_or_phone\", \"description\", \"montant_ht\"]\n      }\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"create_bon_commande\",\n      description: \"Créer un bon de commande brouillon pour un client.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          client_name_or_phone: { type: \"string\", description: \"Nom ou téléphone du client\" },\n          description: { type: \"string\", description: \"Description du bon de commande\" },\n          montant_ht: { type: \"number\", description: \"Montant HT en euros\" },\n          tva_taux: { type: \"number\", description: \"Taux de TVA (ex: 20 pour 20%)\", default: 20 }\n        },\n        required: [\"client_name_or_phone\", \"description\", \"montant_ht\"]\n      }\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"list_recent_leads\",\n      description: \"Lister les derniers leads/prospects.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          limit: { type: \"integer\", description: \"Nombre de leads à retourner\", default: 5 }\n        }\n      }\n    }\n  }\n];\n\nconst tools = isAdmin ? adminTools : standardTools;\n\nreturn {\n  systemPrompt: isAdmin ? adminPrompt : standardPrompt,\n  tools: JSON.stringify(tools),\n  speechResult,\n  callSid,\n  from,\n  isAdmin,\n  clientName,\n  clientEmail,\n  clientId,\n  tenantId\n};"
      },
      "id": "12. Build Prompt",
      "name": "12. Build Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1500,
        250
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'gpt-4o-mini', messages: [{role:'system',content:$json.systemPrompt},{role:'user',content:$json.speechResult}], tools: JSON.parse($json.tools), max_tokens: 250, temperature: 0.5 }) }}"
      },
      "id": "13. OpenAI Chat",
      "name": "13. OpenAI Chat",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "credentials": {
        "openAiApi": {
          "name": "OpenAi account",
          "id": "nSSLzITn7UjPcRBc"
        }
      },
      "position": [
        1700,
        250
      ]
    },
    {
      "parameters": {
        "jsCode": "// Construire TwiML à partir de la réponse IA (directe ou après tool call)\nconst input = $input.first().json;\n\nlet aiReply = input.aiReply || \"Excusez-moi, je n'ai pas pu traiter votre demande.\";\n\n// Nettoyer pour TTS\naiReply = aiReply\n  .replace(/\\*\\*/g, '')\n  .replace(/\\*/g, '')\n  .replace(/#{1,6}\\s/g, '')\n  .replace(/[\\[\\]]/g, '')\n  .replace(/\\n/g, ' ')\n  .replace(/&/g, '&amp;')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;')\n  .replace(/\"/g, '&quot;')\n  .trim();\n\n// Détecter intentions\nconst speech = (input.speechResult || '').toLowerCase();\nconst isGoodbye = speech.includes('au revoir') || speech.includes('merci au revoir') ||\n                  speech.includes('bonne journée') || speech.includes('à bientôt') ||\n                  speech.includes(\"c'est tout\") || speech.includes('terminé');\n\nconst isProspect = speech.includes('intéress') || speech.includes('tarif') || speech.includes('prix') ||\n                   speech.includes('abonnement') || speech.includes('essai') || speech.includes('demo') ||\n                   speech.includes('souscrire') || speech.includes('inscription') || speech.includes('devis') ||\n                   (input.toolUsed === 'create_lead');\n\nconst needsEscalation = speech.includes('bug') || speech.includes('erreur') || speech.includes('bloqué') ||\n                        speech.includes('marche pas') || speech.includes('fonctionne pas') ||\n                        speech.includes('données perdues') || speech.includes('impossible') ||\n                        speech.includes('urgent') || speech.includes('grave');\n\nlet twiml = '';\nif (isGoodbye) {\n  twiml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n  <Say voice=\"Polly.Lea-Neural\" language=\"fr-FR\">${aiReply}</Say>\n  <Hangup/>\n</Response>`;\n} else {\n  twiml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n  <Say voice=\"Polly.Lea-Neural\" language=\"fr-FR\">${aiReply}</Say>\n  <Gather input=\"speech\" language=\"fr-FR\" speechTimeout=\"3\" timeout=\"15\" action=\"https://n8n.talosprimes.com/webhook/twilio-inbound-voice\" method=\"POST\"/>\n  <Say voice=\"Polly.Lea-Neural\" language=\"fr-FR\">Merci d'avoir appelé TalosPrimes. Bonne journée !</Say>\n</Response>`;\n}\n\nreturn {\n  twiml,\n  callSid: input.callSid,\n  from: input.from,\n  speechResult: input.speechResult,\n  aiReply: aiReply.substring(0, 500),\n  isAdmin: input.isAdmin,\n  isGoodbye,\n  isProspect,\n  needsEscalation,\n  clientName: input.clientName || '',\n  toolUsed: input.toolUsed || ''\n};"
      },
      "id": "14. Build TwiML Response",
      "name": "14. Build TwiML Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3100,
        350
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO call_logs (\n  tenant_id, caller_phone, direction, status, notes, \n  urgency_level, sentiment, action_taken, created_at, updated_at\n) VALUES (\n  COALESCE(\n    (SELECT id FROM tenants LIMIT 1),\n    '00000000-0000-0000-0000-000000000000'\n  ),\n  $1,\n  'entrant',\n  'completed',\n  'CallSid:$2$3$4$5 - Q: $6 - R: $7',\n  $8,\n  $9,\n  'REPONDU',\n  NOW(),\n  NOW()\n) RETURNING id",
        "options": {
          "alwaysOutputData": true
        },
        "queryParameters": "={{ [$json.from, $json.callSid, $json.isAdmin ? ' ADMIN' : '', $json.isProspect ? ' [PROSPECT]' : '', $json.needsEscalation ? ' [ESCALADE]' : '', $json.speechResult, $json.aiReply, $json.needsEscalation ? 'URGENT' : 'STANDARD', $json.isProspect ? 'POSITIF' : 'NEUTRE'] }}"
      },
      "id": "15. Log Call",
      "name": "15. Log Call",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "credentials": {
        "postgres": {
          "name": "Supabase Postgres",
          "id": "OGqj65ZoFRileCck"
        }
      },
      "position": [
        3300,
        450
      ]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $('14. Build TwiML Response').first().json.twiml }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "text/xml; charset=utf-8"
              }
            ]
          }
        }
      },
      "id": "16. Respond TwiML",
      "name": "16. Respond TwiML",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        3300,
        300
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO leads (\n  tenant_id, nom, telephone, source, statut, notes, created_at, updated_at\n) SELECT \n  (SELECT id FROM tenants LIMIT 1),\n  'Appel entrant',\n  $1,\n  'telephone',\n  'nouveau',\n  'Prospect détecté par agent vocal - Demande: $2',\n  NOW(),\n  NOW()\nWHERE NOT EXISTS (\n  SELECT 1 FROM leads WHERE telephone LIKE '%' || RIGHT($3, 9) || '%'\n  AND statut != 'abandonne'\n)\nRETURNING id",
        "options": {
          "alwaysOutputData": true
        },
        "queryParameters": "={{ [$('14. Build TwiML Response').first().json.from, $('14. Build TwiML Response').first().json.speechResult.substring(0,300).replace(/'/g, \"''\"), $('14. Build TwiML Response').first().json.from] }}"
      },
      "id": "17. Create Lead",
      "name": "17. Create Lead",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "credentials": {
        "postgres": {
          "name": "Supabase Postgres",
          "id": "OGqj65ZoFRileCck"
        }
      },
      "position": [
        3500,
        500
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO notifications (\n  tenant_id, user_id, type, titre, message, lue, created_at\n) SELECT \n  t.id,\n  u.id,\n  $1,\n  $2,\n  '$3 - Tel: $4 - $5',\n  false,\n  NOW()\nFROM tenants t\nJOIN users u ON u.tenant_id = t.id AND u.role = 'super_admin'\nLIMIT 1\nRETURNING id",
        "options": {
          "alwaysOutputData": true
        },
        "queryParameters": "={{ [$('14. Build TwiML Response').first().json.isProspect ? 'lead' : 'alerte', $('14. Build TwiML Response').first().json.isProspect ? 'Nouveau prospect téléphonique' : 'Escalade agent vocal', $('14. Build TwiML Response').first().json.isProspect ? 'Prospect' : 'Escalade', $('14. Build TwiML Response').first().json.from, $('14. Build TwiML Response').first().json.speechResult] }}"
      },
      "id": "18. Notify Admin",
      "name": "18. Notify Admin",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "credentials": {
        "postgres": {
          "name": "Supabase Postgres",
          "id": "OGqj65ZoFRileCck"
        }
      },
      "position": [
        3500,
        700
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isProspect || $json.needsEscalation }}",
              "value2": true
            }
          ]
        }
      },
      "id": "19. Need Action?",
      "name": "19. Need Action?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        3300,
        600
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT notes FROM call_logs WHERE notes LIKE '%CallSid:$1%' ORDER BY created_at ASC LIMIT 10",
        "options": {
          "alwaysOutputData": true
        },
        "queryParameters": "={{ [$('02. Parser Twilio').first().json.callSid] }}"
      },
      "id": "20. Load History",
      "name": "20. Load History",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "credentials": {
        "postgres": {
          "name": "Supabase Postgres",
          "id": "OGqj65ZoFRileCck"
        }
      },
      "position": [
        1400,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse la réponse OpenAI avec requêtes SQL paramétrisées\nconst openaiResponse = $input.first().json;\nconst prev = $('12. Build Prompt').first().json;\nconst message = openaiResponse.choices?.[0]?.message;\nconst finishReason = openaiResponse.choices?.[0]?.finish_reason;\n\n// === FONCTIONS DE VALIDATION ===\nconst UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nconst PHONE_RE = /^\\+?[0-9]{6,15}$/;\nconst EMAIL_RE = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\nfunction sanitizePhone(p) { return String(p || '').replace(/[^+0-9]/g, '').substring(0, 16); }\nfunction validateNum(n, min, max) { const v = parseFloat(n); return (Number.isFinite(v) && v >= min && v <= max) ? v : 0; }\nfunction safe(s, maxLen) { return String(s || '').substring(0, maxLen || 500); }\n\nif (finishReason === 'tool_calls' && message?.tool_calls?.length > 0) {\n  const toolCall = message.tool_calls[0];\n  const toolName = toolCall.function.name;\n  const toolArgs = JSON.parse(toolCall.function.arguments || '{}');\n  const toolCallId = toolCall.id;\n  const tenantId = prev.tenantId || '';\n\n  const ALLOWED_TOOLS = ['create_lead', 'search_client', 'create_client', 'create_invoice', 'create_bon_commande', 'list_recent_leads'];\n  if (!ALLOWED_TOOLS.includes(toolName)) throw new Error('Tool non autorisé: ' + toolName);\n\n  let sqlQuery = '';\n  let sqlParams = [];\n\n  if (toolName === 'create_lead') {\n    const nom = safe(toolArgs.nom, 100);\n    const prenom = safe(toolArgs.prenom, 100);\n    const email = toolArgs.email && EMAIL_RE.test(toolArgs.email) ? safe(toolArgs.email, 255) : '';\n    const tel = sanitizePhone(toolArgs.telephone || prev.from);\n    const notes = safe(toolArgs.notes, 500);\n    if (!tel) throw new Error('Téléphone requis pour create_lead');\n    sqlQuery = `INSERT INTO leads (tenant_id, nom, prenom, email, telephone, source, statut, notes, created_at, updated_at)\n      SELECT COALESCE(NULLIF($1, '')::uuid, (SELECT id FROM tenants LIMIT 1)), $2, $3, $4, $5, 'telephone_ia', 'nouveau', $6, NOW(), NOW()\n      WHERE NOT EXISTS (SELECT 1 FROM leads WHERE telephone LIKE '%' || RIGHT($5, 9) || '%' AND statut != 'abandonne')\n      RETURNING id, nom, prenom, telephone`;\n    sqlParams = [tenantId, nom, prenom, email, tel, notes];\n  } else if (toolName === 'search_client') {\n    const q = safe(toolArgs.query, 100);\n    if (!q) throw new Error('Query requis pour search_client');\n    sqlQuery = `SELECT id, nom, prenom, email, telephone, raison_sociale, type, statut FROM client_finals WHERE nom ILIKE '%' || $1 || '%' OR prenom ILIKE '%' || $1 || '%' OR telephone LIKE '%' || $1 || '%' OR email ILIKE '%' || $1 || '%' LIMIT 5`;\n    sqlParams = [q];\n  } else if (toolName === 'create_client') {\n    const email = toolArgs.email && EMAIL_RE.test(toolArgs.email) ? safe(toolArgs.email, 255) : '';\n    if (!email) throw new Error('Email valide requis pour create_client');\n    const type = ['b2b', 'b2c'].includes(toolArgs.type) ? toolArgs.type : 'b2c';\n    sqlQuery = `INSERT INTO client_finals (tenant_id, type, nom, prenom, email, telephone, raison_sociale, statut, created_at, updated_at)\n      VALUES ((SELECT id FROM tenants LIMIT 1), $1, $2, $3, $4, $5, $6, 'actif', NOW(), NOW())\n      RETURNING id, nom, prenom, email`;\n    sqlParams = [type, safe(toolArgs.nom, 100), safe(toolArgs.prenom, 100), email, sanitizePhone(toolArgs.telephone), safe(toolArgs.raison_sociale, 255)];\n  } else if (toolName === 'create_invoice') {\n    const ht = validateNum(toolArgs.montant_ht, 0, 999999);\n    const tva = validateNum(toolArgs.tva_taux || 20, 0, 100);\n    const ttc = ht * (1 + tva / 100);\n    const clientQ = safe(toolArgs.client_name_or_phone, 100);\n    if (!clientQ || ht <= 0) throw new Error('Client et montant requis pour create_invoice');\n    const numFacture = 'FA-' + Date.now();\n    sqlQuery = `INSERT INTO invoices (tenant_id, type, client_final_id, numero_facture, date_facture, date_echeance, montant_ht, montant_ttc, tva_taux, description, statut, created_at, updated_at)\n      SELECT (SELECT id FROM tenants LIMIT 1), 'facture_client_final',\n        (SELECT id FROM client_finals WHERE nom ILIKE '%' || $1 || '%' OR telephone LIKE '%' || $1 || '%' LIMIT 1),\n        $2, NOW(), NOW() + INTERVAL '30 days', $3, $4, $5, $6, 'brouillon', NOW(), NOW()\n      RETURNING id, numero_facture, montant_ht, montant_ttc, statut`;\n    sqlParams = [clientQ, numFacture, ht, parseFloat(ttc.toFixed(2)), tva, safe(toolArgs.description, 500)];\n  } else if (toolName === 'create_bon_commande') {\n    const ht = validateNum(toolArgs.montant_ht, 0, 999999);\n    const tva = validateNum(toolArgs.tva_taux || 20, 0, 100);\n    const ttc = ht * (1 + tva / 100);\n    const clientQ = safe(toolArgs.client_name_or_phone, 100);\n    if (!clientQ || ht <= 0) throw new Error('Client et montant requis pour create_bon_commande');\n    const numBdc = 'BDC-' + Date.now();\n    sqlQuery = `INSERT INTO bons_commande (tenant_id, client_final_id, numero_bdc, date_bdc, montant_ht, montant_ttc, tva_taux, description, statut, created_at, updated_at)\n      SELECT (SELECT id FROM tenants LIMIT 1),\n        (SELECT id FROM client_finals WHERE nom ILIKE '%' || $1 || '%' OR telephone LIKE '%' || $1 || '%' LIMIT 1),\n        $2, NOW(), $3, $4, $5, $6, 'brouillon', NOW(), NOW()\n      RETURNING id, numero_bdc, montant_ht, montant_ttc, statut`;\n    sqlParams = [clientQ, numBdc, ht, parseFloat(ttc.toFixed(2)), tva, safe(toolArgs.description, 500)];\n  } else if (toolName === 'list_recent_leads') {\n    const limit = Math.min(Math.max(parseInt(toolArgs.limit) || 5, 1), 20);\n    sqlQuery = `SELECT id, nom, prenom, telephone, email, statut, source, created_at FROM leads ORDER BY created_at DESC LIMIT $1`;\n    sqlParams = [limit];\n  }\n\n  return {\n    hasToolCall: true,\n    toolCallId,\n    toolName,\n    toolArgs: JSON.stringify(toolArgs),\n    sqlQuery,\n    sqlParams,\n    messages: JSON.stringify([\n      {role: 'system', content: prev.systemPrompt},\n      {role: 'user', content: prev.speechResult},\n      message\n    ]),\n    tools: prev.tools,\n    callSid: prev.callSid,\n    from: prev.from,\n    speechResult: prev.speechResult,\n    isAdmin: prev.isAdmin,\n    clientName: prev.clientName || '',\n    clientEmail: prev.clientEmail || ''\n  };\n} else {\n  let aiReply = message?.content || \"Excusez-moi, je n'ai pas pu traiter votre demande.\";\n\n  return {\n    hasToolCall: false,\n    aiReply,\n    callSid: prev.callSid,\n    from: prev.from,\n    speechResult: prev.speechResult,\n    isAdmin: prev.isAdmin,\n    clientName: prev.clientName || '',\n    clientEmail: prev.clientEmail || ''\n  };\n}"
      },
      "id": "21. Parse Response",
      "name": "21. Parse Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1900,
        250
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.hasToolCall }}",
              "value2": true
            }
          ]
        }
      },
      "id": "22. Has Tool Call?",
      "name": "22. Has Tool Call?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        2100,
        250
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "$1",
        "options": {
          "alwaysOutputData": true
        },
        "queryParameters": "={{ [$json.sqlQuery] }}"
      },
      "id": "23. Execute Tool SQL",
      "name": "23. Execute Tool SQL",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "credentials": {
        "postgres": {
          "name": "Supabase Postgres",
          "id": "OGqj65ZoFRileCck"
        }
      },
      "position": [
        2300,
        150
      ]
    },
    {
      "parameters": {
        "jsCode": "// Construire le body pour le 2e appel OpenAI avec le résultat du tool\nconst prev = $('21. Parse Response').first().json;\nconst toolResult = $input.first().json;\nconst messages = JSON.parse(prev.messages);\nconst tools = JSON.parse(prev.tools);\n\n// Ajouter le résultat du tool aux messages\nmessages.push({\n  role: 'tool',\n  tool_call_id: prev.toolCallId,\n  content: JSON.stringify(toolResult)\n});\n\nreturn {\n  jsonBody: JSON.stringify({\n    model: 'gpt-4o-mini',\n    messages,\n    max_tokens: 200,\n    temperature: 0.5\n  }),\n  callSid: prev.callSid,\n  from: prev.from,\n  speechResult: prev.speechResult,\n  isAdmin: prev.isAdmin,\n  clientName: prev.clientName || '',\n  clientEmail: prev.clientEmail || '',\n  toolUsed: prev.toolName\n};"
      },
      "id": "24. Build Tool Body",
      "name": "24. Build Tool Body",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        150
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.jsonBody }}"
      },
      "id": "25. OpenAI Tool Result",
      "name": "25. OpenAI Tool Result",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "credentials": {
        "openAiApi": {
          "name": "OpenAi account",
          "id": "nSSLzITn7UjPcRBc"
        }
      },
      "position": [
        2700,
        150
      ]
    },
    {
      "parameters": {
        "jsCode": "// Extraire la réponse finale après tool call\nconst openaiResponse = $input.first().json;\nconst prev = $('24. Build Tool Body').first().json;\n\nconst aiReply = openaiResponse.choices?.[0]?.message?.content || \"L'opération a été effectuée.\";\n\nreturn {\n  aiReply,\n  callSid: prev.callSid,\n  from: prev.from,\n  speechResult: prev.speechResult,\n  isAdmin: prev.isAdmin,\n  clientName: prev.clientName || '',\n  clientEmail: prev.clientEmail || '',\n  toolUsed: prev.toolUsed || ''\n};"
      },
      "id": "26. Extract Final Reply",
      "name": "26. Extract Final Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2900,
        150
      ]
    }
  ],
  "connections": {
    "01. Webhook Twilio": {
      "main": [
        [
          {
            "node": "02. Parser Twilio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "02. Parser Twilio": {
      "main": [
        [
          {
            "node": "03. Is Callback?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "03. Is Callback?": {
      "main": [
        [
          {
            "node": "06. Extract Speech",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "04. Welcome TwiML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "04. Welcome TwiML": {
      "main": [
        [
          {
            "node": "05. Respond Welcome",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "06. Extract Speech": {
      "main": [
        [
          {
            "node": "07. Has Text?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "07. Has Text?": {
      "main": [
        [
          {
            "node": "10. Detect Admin",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "08. No Text TwiML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "08. No Text TwiML": {
      "main": [
        [
          {
            "node": "09. Respond No Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "10. Detect Admin": {
      "main": [
        [
          {
            "node": "11. Get Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "11. Get Session": {
      "main": [
        [
          {
            "node": "20. Load History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "20. Load History": {
      "main": [
        [
          {
            "node": "12. Build Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "12. Build Prompt": {
      "main": [
        [
          {
            "node": "13. OpenAI Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "13. OpenAI Chat": {
      "main": [
        [
          {
            "node": "21. Parse Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "14. Build TwiML Response": {
      "main": [
        [
          {
            "node": "15. Log Call",
            "type": "main",
            "index": 0
          },
          {
            "node": "16. Respond TwiML",
            "type": "main",
            "index": 0
          },
          {
            "node": "19. Need Action?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "19. Need Action?": {
      "main": [
        [
          {
            "node": "17. Create Lead",
            "type": "main",
            "index": 0
          },
          {
            "node": "18. Notify Admin",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "21. Parse Response": {
      "main": [
        [
          {
            "node": "22. Has Tool Call?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "22. Has Tool Call?": {
      "main": [
        [
          {
            "node": "23. Execute Tool SQL",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "14. Build TwiML Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "23. Execute Tool SQL": {
      "main": [
        [
          {
            "node": "24. Build Tool Body",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "24. Build Tool Body": {
      "main": [
        [
          {
            "node": "25. OpenAI Tool Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "25. OpenAI Tool Result": {
      "main": [
        [
          {
            "node": "26. Extract Final Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "26. Extract Final Reply": {
      "main": [
        [
          {
            "node": "14. Build TwiML Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}